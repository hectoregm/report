\documentclass{article}
\usepackage[left=4cm,right=4cm,top=4cm,bottom=4cm,letterpaper]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\author{Héctor E. Gómez Morales}
\title{Reporte Trabajo Profesional: Proyecto PEAT (Progressive Energy
  Audit Tool)}
\begin{document}
\maketitle
\tableofcontents
\section{Introducción}
Este reporte se enfoca al diseño e implementación de la aplicación
PEAT (Progressive Energy Audit Tool) que es una aplicación web que
ayuda a usuarios de PyMES identificar y monitorear su gasto en
energía, para de esta forma darle un mayor control en sus costos de
energía.

PEAT es producto de una licitación auspiciada por Pacific Gas and
Electric Company (PG\&E), proveedora de gas natural y electricidad
para casi dos tercios del norte de California, USA, para
el desarrollo de una aplicación web enfocada a usuarios PyMES.

Su desarrollo era de importancia critica para PG\&E y al gobierno de
California puesto que su funcionamiento era un requisito en una nueva
ley de facturación de energía eléctrica en 2013. La nueva ley buscaba
lograr distribuir la carga de la red eléctrica, una de las formas
principales para lograr esto era desincentivar el uso de la red
eléctrica en horas picos al darle la facultad a las utilidades como PG\&E
de cobrar tasas mucho mas altas en estas horas.
\section{Planteamiento del problema}
Aunque PG\&E tiene todos los datos de consumo eléctrico y/o gas de
sus clientes, y dado el despliegue previo de los nuevos medidores
inteligentes en la mayor parte de sus clientes se tenia acceso a
información muy detallada del consumo de energía.

Para darle la mayor información y valor a las empresas era
vital obtener mayor contexto de su entorno de operación: numero
de edificios asociados a la cuenta, rubro de la empresa, numero de
empleados, etc. Entre mayor información se pudiera captar sobre la
empresa el sistema daría un desglose mas detallado y útil de sus
consumos de energía. El objetivo era dar la mayor utilidad posible con
la menor información disponible pero fomentando al usuario el dar
mas información para darle un mejor monitoreo de su consumo.

La compañía C3 Energy, en la que trabaje y que gano esta licitación,
contaba con la infraestructura para el procesamiento de una gran
cantidad de datos de consumo de energía puesto que tenia un sistema
de monitoreo de consumo de energía pero enfocada a empresas de nivel
multinacional. El reto era que se pasaba de tener una docena
de clientes, con los cuales se trataba directamente, a lidiar con
cientos de miles de empresas PyMES en las cuales se obtenía una
parte de la información por parte de PG\&E y otra parte por el
empresario.

En resumen el sistema tenia los siguientes principales requerimientos:
\begin{itemize}
\item Tiene que tener una interfase web, usando como autentificacion
  sus credenciales de acceso en el portal web de PG\&E
\item El sistema debe dar información útil aunque el usuario solo de
  el mínimo de información sobre su empresa.
\item El sistema debe proporcionar recomendaciones para disminuir sus
  gastos en energía en base a su consumo e información proporcionada
  hasta el momento
\item Soportar por lo menos a mil usuarios concurrentes
\end{itemize}

\section{Arquitectura Pre-PEAT}
En C3 Energy ya se contaba con toda una infraestructura para el
procesamiento y análisis en tiempo real de datos de consumo eléctrico
y de gas.

En grandes rasgos el sistema constaba de cuatro capas una capa de
almacenamiento de información que era de referencia o datos ya
procesados, otra capa en las que se hacia el análisis de los datos
y que también tomaba el rol de capa de cache. La tercera capa era el
servidor que servía el API para permitía acceder y realizar análisis
sobre las capas de datos anteriores y finalmente la cuarta capa que
era el cliente que realizaba llamadas al API para presentar la
información al usuario final.

\subsection{Bases de Datos}
Las dos primeras capas realizaban y almacenaban información obtenida
de un gran numero de bases de datos externas relacionadas con temas
de energía. Todos estos datos eran concentrados en una base de datos
central en la que se usaba Oracle Database 10g para este rol.

También se contaba con un cluster de Apache Cassandra el cual era usado
para realizar el análisis en tiempo real de los datos, ademas de servir
como capa de cache para los datos mas solicitados en el sistema.

\subsection{Servidor y API}
Sobre la anterior bases de datos se tenia un API que que permita el
hacer consultas y operaciones sobre los datos contenidos y/o analizados
en este sistema. Este API estaba implementado en Javascript bajo Rhino
que corre bajo el JVM, esto daba la ventaja que se podía realizar la
implementación de rutinas criticas en un lenguaje con mejor
rendimiento como Java. De esta forma se tenia que el núcleo del
servidor estaba implementado en Java con el resto del API implementado
en Javascript.

\subsection{Aplicaciones}
Las aplicaciones ya existentes para empresas multinacionales eran del tipo
SPA (Single Page Application) que son aplicaciones web que tienen el fin
de dar una experiencia de usuario similar a la de una aplicación de escritorio.
Esto era implementado usando un framework hecho dentro de la compañía
en Javascript. Se tenia una gran jerarquía de objetos que era
compartida tanto en el servidor como en el cliente, así se tenia que
había una sola fuente de la descripción de los objetos del sistema.

Se hacia un uso extenso de la biblioteca Ext JS que es un framework
en Javascript para construir aplicaciones del tipo SPA, se hacia un particular
uso de su facultad para rápidamente generar todo tipo de gráficas para mostrar
información al usuario.

Entonces tenemos que tanto en el frontend como en el backend se hacia
uso de Javascript principalmente con un núcleo de Java para las partes
que requerían un rendimiento optimo. Esto tenia varias ventajas:

\begin{itemize}
\item Reducir al mínimo el cambio de contexto entre lenguajes entre
  el frontend y el backend
\item Reducir sustancialmente la cantidad de código redundante al no
  tenerse que reimplementar la jerarquía de objetos, que era pasada
  por el server en forma serializada por JSON y deserializada por el
  cliente
\item Había una única representación de una clase por ejemplo la
  clase de edificios la misma clase de Javascript que se usaba para
  esta representación era usada tanto en el server como en el
  cliente.
\end{itemize}

En primera instancia se pensaba realizar el mismo tipo de aplicación
para cubrir los requerimientos de PEAT, es decir realizar un cliente
de Javascript que hiciera uso del API y jerarquía de objetos ya
existente (con ciertas adicciones y modificaciones) y de Ext JS
para la interfase de usuario. Pero en los primeros prototipos se
lograron visualizar varios problemas con este acercamiento:

\begin{itemize}
\item El tiempo para realizar la precarga de todos los módulos y
  objetos dados por el API en el cliente tomaba un tiempo
  considerable (5+ segs). Dado que este sistema era usado por un muy
  reducido numero de personas y que cuando era cargado era usado
  extensamente este penalti por arranque era tolerable
\item El tipo de inferfases y experiencia de usuario que se obtenía
  usando Ext JS eran excelentes para el contexto de mostrar una gran
  cantidad de información al usuario, en PEAT esta información era menor
  y la importancia era de que la experiencia de usuario fuera lo mas fluida y
  rápida posible
\end{itemize}

Entonces se vio el de usar otro tipo de herramientas para construir
aplicaciones finales al usuario que permitieran rehusar todo el API
y jerarquía de objetos asociada a esta.

Después de varios prototipos con varios stacks de tecnología se decido
usar Ruby on Rails que hace uso de lenguaje de programación.
Las razones principales fueron:
\begin{itemize}
\item Gran integración con una gran cantidad de utilerias y bibliotecas para
  desarrollar, diseñar y implementar interfases de usuario
\item Una gran soporte por Rails y bibliotecas de terceros para
  realizar extensas pruebas unitarias, funcionales y de integración,
  por medio de librerías como rspec, cucumber, capybara, etc.
\end{itemize}
\end{document}
