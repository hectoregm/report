\documentclass{article}
\usepackage[left=4cm,right=4cm,top=4cm,bottom=4cm,letterpaper]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\author{Héctor E. Gómez Morales}
\title{Reporte Trabajo Profesional: Proyecto PEAT (Progressive Energy
  Audit Tool)}
\begin{document}
\maketitle
\tableofcontents
\section{Introducción}
Este reporte se enfoca al diseño e implementación de la aplicación
PEAT (Progressive Energy Audit Tool) que es una aplicación web que
permite a los usuarios de PyMES identificar y monitorear su gasto en
energía, para de esta forma darle un mayor control en sus costos de
energía.

PEAT es producto de una licitación auspiciada por Pacific Gas and
Electric Company (PG\&E), proveedora de gas natural y electricidad
para casi dos tercios del norte de California, USA, para
el desarrollo de una aplicación web enfocada a usuarios PyMES.

Su desarrollo era de importancia critica para PG\&E y al gobierno de
California puesto que su funcionamiento era un requisito en una nueva
ley de facturación de energía eléctrica en 2013. La nueva ley buscaba
lograr distribuir la carga de la red eléctrica, una de las formas
principales para lograr esto era desincentivar el uso de la red
eléctrica en horas picos al darle la facultad a las utilidades como PG\&E
de cobrar tasas mucho mas altas en estas horas.

\section{Planteamiento del problema}
PG\&E ha realizado el despliegue de medidores inteligentes en la
mayor parte de sus clientes con lo que se tenia acceso a una información
muy detallada del consumo de energía de sus clientes.

Para darle el mayor valor e información a las empresas era
vital obtener mayor contexto de su entorno de operación: numero
de edificios asociados a la cuenta, rubro de la empresa, numero de
empleados, etc. Entre mayor información se pudiera captar sobre la
empresa el sistema tendría mas facilidad en obtener un desglose
mas correcto y útil de sus consumos de energía.

El objetivo era dar la mayor utilidad posible con la menor
información disponible pero fomentando al usuario el dar mas
información para darle un mejor control de su consumo energético.

La compañía C3 Energy, en la que trabaje y que gano esta licitación,
contaba con la infraestructura para el procesamiento de una gran
cantidad de datos de consumo de energía puesto que tenia un sistema
de monitoreo de consumo de energía pero enfocada a empresas de nivel
multinacional. El reto era que se pasaba de tener una docena
de clientes, con los cuales se trataba directamente, a lidiar con
cientos de miles de empresas PyMES en las cuales se obtenía una
parte de la información por parte de PG\&E y otra parte por el
empresario.

En grandes rasgos el sistema tenia los siguientes requerimientos:
\begin{itemize}
\item Tener una interfase web, usando como autentificación
  sus credenciales de acceso en el portal web de PG\&E.
\item El sistema debe dar información útil aunque el usuario solo de
  el mínimo de información sobre su empresa.
\item El sistema debe proporcionar recomendaciones para disminuir sus
  gastos en energía en base a su consumo e información proporcionada
  hasta el momento
\item Soportar por lo menos a mil usuarios concurrentes
\end{itemize}

\section{Arquitectura Previa}
En C3 Energy ya se contaba con toda una infraestructura para el
procesamiento y análisis en tiempo real de datos de consumo eléctrico
y de gas.

En grandes rasgos el sistema constaba de cuatro capas una capa de
almacenamiento de información que era de referencia o datos ya
procesados, otra capa en las que se hacia el análisis de los datos
y que también tomaba el rol de capa de cache. La tercera capa era el
servidor que servía el API para permitía acceder y realizar análisis
sobre las capas de datos anteriores y finalmente la cuarta capa que
era el cliente que realizaba llamadas al API para presentar la
información al usuario final.

\subsection{Bases de Datos}
Las dos primeras capas realizaban y almacenaban información obtenida
de un gran numero de bases de datos externas relacionadas con temas
de energía. Todos estos datos eran concentrados en una base de datos
central en la que se usaba Oracle Database 10g para este rol.

También se contaba con un cluster de Apache Cassandra el cual era usado
para realizar el análisis en tiempo real de los datos, además de servir
como capa de cache para los datos mas solicitados en el sistema.

\subsection{Servidor y API}
Sobre la anterior bases de datos se tenia un API que que permita el
hacer consultas y operaciones sobre los datos contenidos y/o analizados
en este sistema. Este API estaba implementado en Javascript bajo Rhino
que corre bajo la maquina virtual de Java (JVM), esto daba la ventaja
que se podía realizar la implementación de rutinas criticas en un
lenguaje con mejor rendimiento como Java. De esta forma se tenia que el
núcleo del servidor estaba implementado en Java con el resto del API
implementado en Javascript.

\subsection{Aplicaciones}
Las aplicaciones ya existentes para empresas multinacionales eran del tipo
SPA (Single Page Application) que son aplicaciones web que tienen el fin
de dar una experiencia de usuario similar a la de una aplicación de escritorio.
Esto era implementado usando un framework hecho dentro de la compañía
en Javascript. Se tenia una gran jerarquía de objetos que era
compartida tanto en el servidor como en el cliente, así se tenia que
había una sola fuente de la descripción de los objetos del sistema.

Se hacia un uso extenso de la biblioteca Ext JS que es un framework
en Javascript para construir aplicaciones del tipo SPA, se hacia un uso particular
a su facultad para rápidamente generar todo tipo de gráficas para mostrar
información al usuario.

Entonces tenemos que tanto en el frontend como en el backend se hacia
uso de Javascript principalmente con un núcleo de Java para las partes
que requerían un rendimiento óptimo. Esto tenia varias ventajas:

\begin{itemize}
\item Reducir al mínimo el cambio de contexto entre lenguajes entre
  el frontend y el backend.
\item Reducir sustancialmente la cantidad de código redundante al no
  tenerse que reimplementar la jerarquía de objetos, que era pasada
  por el servidor en forma serializada por JSON y deserializada por el
  cliente
\item Había una única representación de una clase por ejemplo la
  clase de edificios era una clase de Javascript que se usaba para
  tanto en el servidor como en el cliente.
\end{itemize}

En primera instancia se pensaba realizar el mismo tipo de aplicación
para cubrir los requerimientos de PEAT, es decir realizar un cliente
de Javascript que hiciera uso del API y jerarquía de objetos ya
existente (con ciertas adicciones y modificaciones) y de Ext JS
para la interfase de usuario. Pero en los primeros prototipos se
lograron visualizar varios problemas con este acercamiento:

\begin{itemize}
\item El tiempo para realizar la precarga de todos los módulos y
  objetos dados por el API en el cliente tomaba un tiempo
  considerable (5+ segs.). Los sistema anteriores eran usados
  por un numero reducido de personas autorizadas, que hacían uso
  extensivo del sistema en sesiones de larga duración, por lo
  que este tiempo de arranque era tolerable.
\item El tipo de interfases y experiencia de usuario que se obtenía
  usando Ext JS eran excelentes para el contexto de mostrar una gran
  cantidad de información al usuario, en PEAT esta información era menor
  y la importancia era de que la experiencia de usuario fuera lo mas fluida y
  rápida posible
\end{itemize}

Entonces se vio el de usar otro tipo de herramientas para construir
aplicaciones finales al usuario pero que permitieran rehusar todo el API
y jerarquía de objetos asociada a esta.

Después de varios prototipos con varios stacks de tecnología se decido
usar Ruby y el framework Ruby on Rails.
Las razones principales fueron:
\begin{itemize}
\item Gran integración con una gran cantidad de utilerías y bibliotecas para
  desarrollar, diseñar y implementar interfases de usuario.
\item Ruby tiene una gran capacidad para implementar Domain Specific Languages (DSL)
  que permiten realizar lenguajes específicos al problema que se esta resolviendo,
  en nuestro caso realizar una integración con una jerarquía de clases
\item Una gran soporte por Rails y bibliotecas de terceros para
  realizar extensas pruebas unitarias, funcionales y de integración,
  por medio de librerías como rspec, cucumber, capybara, etc.
\end{itemize}
\end{document}
