\chapter{Fundamentos teóricos}

\section{Patrón Modelo-Vista-Controlador (MVC)}
El patrón Modelo Vista Controlador (MVC) es probablemente el patrón
mas utilizado y citado para el desarrollo de interfaces de usuario y sistemas web.
MVC consiste de tres tipos de objetos \cite{22_martin_fowler_mvc}:

\begin{itemize}
\item Modelo: representación de la información de dominio del sistema.
\item Vista: representación visual del modelo.
\item Controlador: define la forma en que la interfaz reacciona a la entrada
  del usuario.
\end{itemize}

% FIXME: Hacer diagrama en español de MVC en sistemas web
\jcimage{1.0}{imagenes/MVC-Rails.png}{Patrón MVC para sistemas web \cite{15_agile_hansson}.}

MVC fue ideado originalmente para aplicaciones gráficas convencionales,
donde los desarrolladores encontraron que la separación de responsabilidades,
entre la presentación (vista y controlador) y el dominio (modelo), fomentadas
por el patrón llevan a un menor acoplamiento lo que hacia al código
mucho mas fácil de escribir y mantener (Ver Figura 2.1).

MVC desacopla vistas y modelos mediante el establecimiento de un
protocolo de suscripción / notificación. La vista debe asegurarse
de que su aspecto visual refleje el estado del modelo. Cada vez que cambian
los datos del modelo, el modelo notifica a las vistas que depende de ella.
Este enfoque permite conectar múltiples vistas a un modelo para proporcionar
diferentes presentaciones. También puede crear nuevas vistas para un modelo
sin reescribir este último \cite{14_gamma_1995}.

\subsection{MVC y Rails}
En el marco de trabajo Rails se hace uso de MVC como patrón de arquitectura
para implementar sistemas web. En Rails los modelos se definen haciendo
uso de la biblioteca \textit{ActiveRecord}, esta biblioteca implementa el
patrón de mapeo objeto-relacional (\textit{Object-relational mapping},
ORM) para facilitar el acceso de información contenida en
bases de datos relacionales, dado que es el caso típico en sistemas web
convencionales.

En Rails, la vista es responsable de la creación de la respuesta dada para
ser mostrada en un navegador. En su forma mas simple, una
vista es un trozo de código HTML que muestra un texto fijo. Mas típicamente
se requiere mostrar contenido dinámico creado por una acción en un controlador.
El contenido dinámico es generado por medio de plantillas, el esquema
de plantillas más común es llamado Ruby Embebido (\textit{Embedded Ruby}, ERB),
el cual inserta pedazos de código de Ruby dentro de una vista, similar a la forma
como se hace en otros marcos de trabajo como PHP o JSP. También se pude hacer uso de
Ruby Embebido para incrustar pedazos de código Javascript en el servidor,
para ser ejecutados en el navegador, lo cual permite crear interfases
dinámicas haciendo uso de \textit{Asynchronous JavaScript and XML} (AJAX).

Finalmente en Rails los controladores son el centro lógico del sistema. Coordinan
la interacción entre el usuario, las vistas y el modelo
\cite{15_agile_hansson}.

\subsection{MVC y PEAT}
\texttt{PEAT} saca provecho del patrón MVC de las siguientes maneras \cite{15_agile_hansson}:

\begin{enumerate}
\item Modelo: dado que en un principio los servicios web de recomendaciones y
  desagregación estaban en construcción se hizo uso de la biblioteca ActiveRecord
  para tener datos reales estáticos para permitir la implementación
  de la interfaz de usuario. Posteriormente se reemplazaron éstos modelos
  por nuevos modelos que hacían uso de los servicios web del \textit{backend},
  por medio de la biblioteca \texttt{Bezel}. Dado que hay un desacoplamiento
  entre los modelos y las vistas esto no implicó grandes cambios al hacer el
  reemplazo.
\item Vista: haciendo uso de plantillas se generan representaciones de los
  principales modelos del sistema en HTML y JSON. Para ciertos modelos, como
  las recomendaciones y los reportes de consumo, se tenia una tercera
  representación en forma de PDF del modelo.
\end{enumerate}

\section{Servicios web RESTful}
La \textit{World Wide Web Consortium}, W3C, define que un servicio web
en general es un sistema de software diseñado para dar soporte a interacciones
máquina-máquina a través de una red informática \cite{17_w3c_webservice}.
Su implementación nació de tener diferentes sistemas que puedan intercambiar
datos entre ellos.

La Transferencia de Estado Representacional (\textit{Representational State Transfer}, REST) es una arquitectura de software para la implementación de servicios web.
En REST se define la existencia de recursos (elementos de información), donde
cada recurso tiene un conjunto de representaciones posibles.
Por ejemplo una lista de errores por arreglar (recurso) puede ser presentado en
forma de un documento XML, una pagina HTML o un archivo CSV (representaciones).

\vspace{2.5mm}

Además se tienen cuatro características principales \cite{1_richardson_2007}:

\begin{itemize}
\item Protocolo cliente/servidor sin estado (\textit{stateless}): cada mensaje
  HTTP contiene toda la información necesaria para comprender la petición.
  Esto implica que ni el cliente ni el servidor necesitan recordar ningún
  tipo de estado.
\item Conectividad (\textit{connectedness}): las representaciones son un hipermedio
  en el cual se tienen ligas a otros recursos. Como resultado de esto, es posible
  navegar de un recurso REST a muchos otros, sin necesidad de una
  infraestructura adicional.
\item Direccionabilidad (\textit{addressability}): la capacidad para
  identificar los recursos del sistema. Cada recurso es direccionable únicamente
  a través de su Identificador de Recursos Uniforme (\textit{Uniform Resource Identifier}, URI).
\item Interfaz uniforme (\textit{uniform interface}): se tiene un conjunto de
  operaciones bien definidas que se aplican a todos los recursos del sistema.
  Se usan los métodos de HTTP para definir las operaciones más importantes
  como son GET, POST, PUT, PATCH y DELETE.
\end{itemize}

Los servicios web que implementan una arquitectura REST se suelen llamar
servicios web RESTful.

\subsection{REST y Rails}

La arquitectura REST es parte vital de Rails, todo el enrutamiento y
manejo de peticiones se basa en esta arquitectura.

En REST se hace uso de un conjunto finito de verbos para operar sobre otro
conjunto de objetos. Dado que estamos usando HTTP como capa de transporte, los
verbos corresponden a los métodos HTTP (GET, POST, PUT, PATCH, y DELETE).
Los objetos corresponden a los recursos del sistema, los cuales son etiquetados
usando un (\textit{Uniform Resource Locator} URL).

Un navegador solicita páginas de Rails al hacer una petición para una dirección URI
haciendo uso de un método HTTP específico, como GET o POST. Cada método es una
petición para realizar una operación sobre el recurso.

Haciendo uso de la interfaz uniforme, Rails define todo un conjunto de rutas
para un recurso, tomando como ejemplo el concepto de edificio (\textit{Building}),
entonces, se define el recurso y sus rutas asociadas con lo siguiente:

\begin{verbatim}
resources :buildings
\end{verbatim}

En la Figura 2.2 se pueden ver las rutas y verbos asociados para las principales
operaciones sobre el recurso \textit{buildings}, esto acelera en gran medida
el desarrollo de servicios web.

% FIXME: Hacer tabla de rutas para building y en español
\jcimage{1.0}{imagenes/REST-Rails.png}{Rutas y verbos para el recurso \textit{buildings} \cite{18_rails_rest}.}

\subsection{REST y PEAT}
La arquitectura REST influye en las tres partes principales de \texttt{PEAT}

\begin{itemize}
\item \textit{Frontend}: por medio de Rails se implementa un servicio web RESTful
  para proveer de información a la interfaz gráfica del sistema.
\item \textit{Backend}: los servicios web que componen el \textit{backend}, como el
  sistema de recomendaciones, son del tipo RESTful. El recurso principal del sistema
  es el de edificio (\textit{Building}) del cual se tiene alrededor de los demás
  recursos del sistema.
\item \textit{Middleware}: la biblioteca \texttt{Bezel} se beneficia gracias al hecho
  de que el \textit{backend} sea de tipo RESTful, pues facilita la integración del
  sistema, dado que hace un mapeo casi directo de los recursos a clases y objetos.

\end{itemize}


\section{Desarrollo guiado por pruebas y comportamiento}
El tener código fuente que sea limpio y que además tenga la funcionalidad deseada
es uno de los principales objetivos en cualquier sistema. Cabe señalar que
por código limpio se entiende por código fuente que sea fácil de entender
y de modificar \cite{4_beck_2003}.

El desarrollo guiado por pruebas (\textit{Test Driven Development}, TDD) y el
desarrollo guiado por comportamiento (\textit{Behavior Driven Development}, BDD)
son prácticas de ingeniería de software que tiene por objetivo el obtener código
limpio y funcional.

\subsection{Desarrollo guiado por pruebas (TDD)}
TDD es una practica de software que involucra el escribir las pruebas antes de
realizar la implementación, esto mejora el diseño y eficacia de la implementación.
Al escribir las pruebas antes que el código fuente, contrario al proceso habitual,
permite que las pruebas ayuden a guiar el diseño del código fuente en pequeños
pasos. En el largo plazo este proceso implementa un código fuente bien
estructurado que es fácil de mantener y de modificar\cite{4_beck_2003}.

\vspace{2.5mm}

El proceso clásico en TDD es el siguiente \cite{12_rappin_2010}:
\begin{enumerate}
\item Implementar una prueba: esta prueba debe ser breve y debe probar
  solamente una unidad de código (función, clase o módulo).
\item Asegurar que la prueba falle: se verifica que la prueba falle antes
  de escribir cualquier código. Esto es para asegurar que la prueba realmente
  hace lo que se espera de ella.
\item Implementar la nueva funcionalidad: se implementa el mínimo código de
  forma que la prueba pase satisfactoriamente.
\item Mejorar el código fuente: se elimina toda repetición que se origino al
  implementar la nueva funcionalidad para lograr que la prueba pase
  satisfactoriamente, también se realiza cualquier otra optimización y/o
  abstracción necesaria. Esta proceso recibe el nombre de
  refactorización, es parte vital del proceso.
\end{enumerate}

Este proceso se repite hasta que se termina de implementar toda la funcionalidad
del sistema. Al seguir este proceso, en teoría, se asegura que el código fuente
siempre es lo mas simple posible y que esta completamente.

\subsubsection{Ventajas}
TDD va mas allá de la mera verificación al hacer uso de las pruebas para
mejorar la estructura del código fuente, por esto es que TDD es una practica
de software y no solamente una herramienta de verificación.

Al continuamente alinear el código fuente a las pruebas se obtiene código fuente
conformado por pequeños métodos, cada uno de los cuales tiene solamente tiene
una sola responsabilidad. Estos métodos tienden a tener bajo acoplamiento y
con pocos efectos laterales, lo que facilita su comprensión y mantenimiento.

\subsubsection{Desventajas}
TDD no es un substituto para pruebas de aceptación, es decir pruebas que confirman
que el software funciona según los requerimientos del cliente.

TDD asume que se conoce el resultado esperado que se quiere verificar,
cuando los requerimientos no son totalmente claros entonces TDD no es tan benéfico
puesto que es difícil escribir pruebas de un proceso que no se conocen en detalle.

\subsubsection{RSpec}
RSpec es un marco de trabajo del proceso TDD/BDD para el lenguaje de programación
Ruby. RSpec define un lenguaje de dominio especifico (DSL) para implementar pruebas
unitarias y de aceptación \cite{23_chelimsky_2010}.

Un ejemplo de una prueba unitaria es:
\begin{verbatim}
describe Bezel::Client do
  # Contexto de la prueba, teniendo el API versión 2 del servidor C3.
  context "v2" do

    # Nombre de la prueba
    it "escapes unicode sequences" do
      body = Bezel.client.send(:generate_body,{"value"=>"Déconnexion"})

      # Aserciones sobre el comportamiento esperado.
      body.should_not include('é')
      body.should include('\u00e9')
    end
  end
end
\end{verbatim}

El método \textit{it} crea un ejemplo del comportamiento de \textit{Bezel::Client}
dentro de un contexto, el cual es que el servidor C3 esta corriendo la versión 2.

\subsection{Desarrollo guiado por comportamiento (BDD)}
BDD es igual que TDD una practica de software que involucra el escribir las pruebas
antes de escribir el código fuente y la refactorización continua del código fuente.
Pero mientras que TDD se enfoca en probar unidades de código en BDD el enfoque es
probar el comportamiento en la interacción de un subconjunto de módulos del
sistema.

Además BDD hace uso de lenguajes DSL que tratan de ser lo mas cercano a un
lenguaje natural (casi siempre ingles) con el cual expresar el comportamiento
y los resultados esperados del sistema.

En BDD se tiene que las pruebas son pruebas de aceptación que especifican el
comportamiento de varias partes del sistema trabajando juntas.


En las pruebas de integracion se definen una serie de escenarios los cuales
surgen de los casos de uso definidos para el sistema. Estos escenarios casi
siempre se especifican en un lenguaje DSL que hace uso de lenguaje natural
(casi siempre ingles) para definir el comportamiento esperado del sistema.

\subsubsection{Cucumber}
Cucumber es una biblioteca que permite el definir y ejecutar pruebas de
aceptacion/integracion escritas usando BDD. Define un lenguaje llamado
Gherkin que permite escribir escenarios en texto de lenguaje natural

Con escenario tiene la siguiente forma:
\begin{verbatim}
\end{verbatim}







son prácticas de ingeniería de software que involucran el escribir las pruebas
antes de escribir el código fuente y la refactorización que involucra revisar el
diseño y remover cualquier repetición \cite{4_beck_2003}\cite{23_chelimsky_2010}.

Mientras en TDD el enfoque es probar unidades de código (función, clase o módulo),
en BDD el enfoque es probar el comportamiento de partes del sistema o el sistema
completo.
\subsection{TDD/BDD y PEAT}


El desarrollo guiado por pruebas (\textit{Test Driven Development}, TDD) y el
desarrollo guiado por comportamiento (\textit{Behavior Driven Development}, BDD)
son prácticas de ingeniería de software que involucran el escribir las pruebas
antes de escribir el código fuente y la refactorización que involucra revisar el
diseño y remover cualquier repetición \cite{4_beck_2003}\cite{23_chelimsky_2010}.

Mientras en TDD el enfoque es probar unidades de código (función, clase o módulo),
en BDD el enfoque es probar el comportamiento de partes del sistema o el sistema
completo.

\vspace{2.5mm}

TDD/BDD definen un ciclo de pasos para guiar el desarrollo:

\begin{enumerate}
\item Rojo: se escribe una prueba y se verifica que ésta falle.
\item Verde: se implementa el mínimo código de forma que la prueba pase
  satisfactoriamente
\item Refactorizar: se elimina toda repetición que se origino al
  hacer que la prueba pase satisfactoriamente.
\end{enumerate}

%\jcimage{1.0}{imagenes/TDD-BDD.png}{Ciclo TDD/BDD.}
