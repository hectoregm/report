\chapter{Fundamentos teóricos}

\section{Patrón Modelo-Vista-Controlador (MVC)}
El patrón Modelo Vista Controlador (MVC) es probablemente el patrón
mas utilizado y citado para el desarrollo de interfaces de usuario y sistemas web.
MVC consiste de tres tipos de objetos:

\begin{itemize}
\item Modelo: representación de la información de dominio del sistema.
\item Vista: representación visual del modelo.
\item Controlador: define la forma en que la interfaz reacciona a la entrada
  del usuario.
\end{itemize}

\jcimage{1.0}{imagenes/MVC-Rails.png}{Patrón MVC para sistemas web \cite{15_agile_hansson}.}

MVC fue ideado originalmente para aplicaciones gráficas convencionales,
donde los desarrolladores encontraron que la separación de responsabilidades,
entre la presentación (vista y controlador) y el dominio (modelo), fomentadas
por el patrón llevan a un menor acoplamiento lo que hacia al código
mucho mas fácil de escribir y mantener (Ver Figura 2.1).

MVC desacopla vistas y modelos mediante el establecimiento de un
protocolo de suscripción / notificación. La vista debe asegurarse
de que su aspecto visual refleje el estado del modelo. Cada vez que cambian
los datos del modelo, el modelo notifica a las vistas que depende de ella.
Este enfoque permite conectar múltiples vistas a un modelo para proporcionar
diferentes presentaciones. También puede crear nuevas vistas para un modelo
sin reescribir este último \cite{14_gamma_1995}.

\subsection{MVC y Rails}
En el marco de trabajo Rails se hace uso de MVC como patrón de arquitectura
para implementar sistemas web. En Rails los modelos se definen haciendo
uso de la biblioteca \textit{ActiveRecord}, esta biblioteca implementa el
patrón de mapeo objeto-relacional (\textit{Object-relational mapping}
(\textit{ORM})) para facilitar el acceso de información contenida en
bases de datos relacionales, dado que es el caso típico en sistemas web
convencionales.

En Rails, la vista es responsable de la creación de la respuesta dada para
ser mostrada en un navegador. En su forma mas simple, una
vista es un trozo de código HTML que muestra un texto fijo. Mas típicamente
se requiere mostrar contenido dinámico creado por una acción en un controlador.
El contenido dinámico es generado por medio de plantillas, el esquema
de plantillas más común es llamada \textit{Embedded Ruby} (ERB),
el cual inserta pedazos de código Ruby dentro de una vista, similar a la forma
como se hace en otros marcos de trabajo como PHP o JSP. También se pude hacer uso de
ERB para incrustar pedazos de código Javascript en el servidor
para ser ejecutados en el navegador, lo cual permite crear interfases
dinámicas haciendo uso de \textit{Asynchronous JavaScript and XML} (AJAX).

Finalmente en Rails los controladores son el centro lógico del sistema. Coordinan
la interacción entre el usuario, las vistas y el modelo
\cite{15_agile_hansson}.

\subsection{MVC y PEAT}
\texttt{PEAT} saca provecho del patrón MVC de las siguientes maneras:

\begin{enumerate}
\item Modelo: dado que en un principio los servicios web de recomendaciones y
  desagregación estaban en construcción se hizo uso de la biblioteca ActiveRecord
  para tener datos reales estáticos para permitir la implementación
  de la interfaz de usuario. Posteriormente se reemplazaron estos modelos
  por nuevos modelos que hacían uso de los servicios web del \textit{backend},
  por medio de la biblioteca \texttt{Bezel}. Dado que hay un desacoplamiento
  entre los modelos y las vistas esto no implico grandes cambios al hacer el
  reemplazo.
\item Vista: haciendo uso de plantillas se generan representaciones HTML
  y JSON de los principales modelos del sistema. Para ciertos modelos como
  las recomendaciones se tenia una tercera representación en forma de PDF
  del modelo.
% FIXME: Escribir sobre beneficios en contexto de los controladores
\end{enumerate}

\section{Servicios web RESTful}
La \textit{World Wide Web Consortium} (W3C) define que un servicio web
en general es un sistema de software diseñado para dar suporte a interacciones
máquina-máquina a través de una red informática \cite{17_w3c_webservice}.
Su implementación es por la necesidad de que diferentes sistemas puedan
intercambiar datos entre ellos.

La Transferencia de Estado Representacional (\textit{Representational State Transfer}
 REST) es una arquitectura de software para la implementación de servicios web.
En REST se define la existencia de recursos (elementos de información), donde
cada recurso tiene un conjunto de representaciones posibles.
Por ejemplo una lista de errores por arreglar (recurso) puede ser presentado en
forma de un documento XML, una pagina HTML o un archivo CSV (representaciones).

Además se tienen cuatro características principales \cite{1_richardson_2007}:

\begin{itemize}
\item Protocolo cliente/servidor sin estado (\textit{stateless}): cada mensaje
  HTTP contiene toda la información necesaria para comprender la petición.
  Esto implica que ni el cliente ni el servidor necesitan recordar ningún
  tipo de estado.
\item Conectividad (\textit{connectedness}): las representaciones son un hipermedio
  en el cual se tienen ligas a otros recursos. Como resultado de esto, es posible
  navegar de un recurso REST a muchos otros, sin necesidad de una
  infraestructura adicional.
\item Direccionabilidad (\textit{addressability}): la capacidad para
  identificar los recursos del sistema. Cada recurso es direccionable únicamente
  a través de su Identificador de Recursos Uniforme (\textit{Uniform Resource Identifier} URI).
\item Interfaz uniforme (\textit{uniform interface}): se tiene un conjunto de
  operaciones bien definidas que se aplican a todos los recursos del sistema.
  Se usan los métodos de HTTP pare definir las operaciones mas importantes
  que son GET, POST, PUT, PATCH y DELETE.
\end{itemize}

Los servicios web que implementan una arquitectura REST se suelen llamar
servicios web RESTful.

\subsection{REST y Rails}

La arquitectura REST es parte vital de Rails, todo el enrutamiento y
manejo de peticiones se basa en esta arquitectura.

En REST se hace uso de un conjunto finito de verbos para operar sobre otro
conjunto de objetos. Dado que estamos usando HTTP como capa de transporte, los
verbos corresponden a los métodos HTTP (GET, POST, PUT, PATCH, y DELETE).
Los objetos corresponden a los recursos del sistema, los cuales son etiquetados
usando URL.

Un navegador solicita páginas de Rails al hacer una petición para una dirección URI
haciendo uso de un método HTTP específico, como GET o POST. Cada método es una
petición para realizar una operación sobre el recurso.

Haciendo uso de la interfaz uniforme, Rails define toda un conjunto de rutas
para un recurso, tomando como ejemplo el concepto de edificio. Se define
el recurso y sus rutas asociadas con lo siguiente:

\begin{verbatim}
resources :buildings
\end{verbatim}

En la Figura 2.2 se pueden ver las rutas y verbos asociados para las principales
operaciones sobre el recurso \textit{buildings}, esto acelera en gran medida
el desarrollo de servicios web.

\jcimage{1.0}{imagenes/REST-Rails.png}{Rutas y verbos para el recurso \textit{buildings} \cite{18_rails_rest}.}

\subsection{REST y PEAT}
La arquitectura REST influye en las tres partes principales de \texttt{PEAT}

\begin{itemize}
\item \textit{Frontend}: por medio de Rails se implementa un servicio web RESTful
  para proveer de información a la interfaz gráfica del sistema.
\item \textit{Backend}: los servicios web que componen el \textit{backend}, como el
  sistema de recomendaciones, son del tipo RESTful. El recurso principal del sistema
  es el de edificio (\textit{Building}) del cual se tienen alrededor los demás
  recursos del sistema.
\item \textit{Middleware}: la biblioteca \texttt{Bezel} saca provecho del hecho
  de que el \textit{backend} sea de tipo RESTful para facilitar la integración del
  sistema, dado que hacer un mapeo de los recursos a clases y objetos es
  casi directa.

\end{itemize}


\section{Desarrollo guiado por pruebas y por comportamiento}
El desarrollo guiado por pruebas (\textit{Test Driven Development} TDD) y el
desarrollo guiado por comportamiento (\textit{Behavior Driven Development} BDD)
son practicas de ingeniería de software que involucran el escribir las pruebas
antes de escribir el código a probar y la refactorización que involucra revisar el
diseño y remover cualquier duplicación.

Mientras en TDD el enfoque es probar unidades de código (función, clase o módulo)
en BDD el enfoque es probar el comportamiento de partes del sistema o el sistema
completo.

TDD/BDD definen un ciclo de pasos para guiar el desarrollo:

\begin{enumerate}
\item Rojo: se escribe una prueba y se verifica que esta falla.
\item Verde: se implementa el mínimo código de forma que la prueba pase
  satisfactoriamente
\item Refactorizar: se elimina toda duplicación generada en hacer que
  la prueba pase.
\end{enumerate}

%\jcimage{1.0}{imagenes/TDD-BDD.png}{Ciclo TDD/BDD.}
