\chapter{Despliegue a producción y optimizaciones}

La etapa para desplegar una aplicación es una etapa de creciente importancia ya
que por un lado hace algunos años las aplicaciones web se desarrollaban bajo el
modelo de tres capas: la base de datos, el servidor de la aplicación y el servidor
web; actualmente se tienen mas servicios que deben estar en línea sobre todo para
garantizar un servicio concurrente; caches, equilibradores de carga, servidores
de cola, etcétera. Por lo que automatizar el despliegue de una aplicación en sus
diferentes contextos, desarrollo, producción y pruebas, es de vital importancia
para el desarrollo de software en tiempo y en forma.

\section{Despliegue continuo}

El despliegue continuo (\textit{Continuous Delivery}, CD) es una práctica de software
en la cual se implementa software de tal forma de que éste pueda ser desplegado a
producción en cualquier momento\cite{27_martin_fowler_cd}. Su objetivo es crear,
probar y liberar software más rápido y con mayor frecuencia.

\vspace{2.5mm}

Se considera que un sistema implementa el despliegue continuo cuando
\cite{27_martin_fowler_cd}:
\begin{itemize}
\item El sistema puede ser desplegado a producción en cualquier momento del
  ciclo de desarrollo.
\item Se tiene una rápida retroalimentación sobre la capacidad del sistema
  para ser desplegado en producción al realizarse cambios en el sistema.
\item Se puede desplegar de forma sencilla cualquier versión del software para
  cualquier entorno.
\end{itemize}

Los principales beneficios de esta práctica son:
\begin{itemize}
\item Reducción del riesgo de despliegue: dado que se realizan despliegues
  a producción de forma recurrente los cambios contenidos en cada despliegue
  son menores por lo que hay menores posibilidades de errores y si un error
  se presenta en mas fácil de localizar y arreglar.
\item Retroalimentación del usuario: uno de los mayores riesgos en la ingeniería
  del software es el desarrollar un sistema que no es útil para el cliente o usuario.
  Por lo tanto obtener retroalimentación sobre el desarrollo del sistema de forma
  rápida y frecuente permite evaluar que tan útil es el sistema para el usuario.
\end{itemize}

En \texttt{PEAT} los riesgos de lograr un despliegue a producción exitoso
eran más grandes de lo habitual dada la complejidad del sistema y la cantidad
de requerimientos. Además PG\&E requería el despliegue del sistema en ambientes
de pruebas previo a un despliegue del sistema en el ambiente de producción.
La implementación de un proceso de despliegue continuo para \texttt{PEAT} fue de
vital importancia para cumplir con las necesidades del cliente.

\vspace{2.5mm}

Para PG\&E era necesario que se tuvieran los siguientes ambientes:
\begin{itemize}
\item \textit{peattest}: este ambiente es usado para hacer pruebas con usuarios
  seleccionados por PG\&E para obtener retroalimentación sobre el sistema.
\item \textit{peatqa}: este ambiente es usado por PG\&E para realizar control de
  calidad y de rendimiento.
\item \textit{peatprod}: este ambiente es el ambiente final de producción.
\end{itemize}

Para uso interno en C3 Energy se tenia además el ambiente \textit{peatstage}
el cual era usado para realizar pruebas de rendimiento y de control de calidad.

En total se tenían cuatro ambientes, los cuales tenían que tener ser lo mas
parecidos en su configuración a la configuración del ambiente de producción
principalmente para que las pruebas de calidad y de rendimiento regresaran resultados
lo mas cercanos al comportamiento del sistema en el ambiente de producción.
Dados estos requerimientos la implementación del proceso de despliegue continuo para
el sistema \texttt{PEAT} era la mejor forma para manejar el despliegue del sistema
en esta diversidad de ambientes.

\subsection{Proceso de despliegue}

En el despliegue continuo se tiene al proceso de despliegue (\textit{deployment
  pipeline}) como concepto central, el cual en esencia es la implementación
automatizada de los procesos de configuración, construcción, prueba y despliegue de
un sistema \cite{28_humble_farley_2011}.

\vspace{2.5mm}

Este proceso tiene las siguientes ventajas:
\begin{itemize}
\item Visibilidad: todas las etapas del sistema de despliegue son visibles
  para todos los miembros del equipo.
\item Retroalimentación: los miembros del equipo obtiene información sobre los
  problemas en el momento en que ocurren de modo que son capaces de dar solución
  a éstos rápidamente.
\item Despliegue: por medio de un proceso totalmente automatizado se puede
  desplegar y liberar cualquier versión del sistema en cualquier ambiente y en
  cualquier momento.
\end{itemize}

El proceso de despliegue se conforma de una serie de etapas de validación por las
que el sistema debe pasar para llegar al ambiente de producción. Para el sistema
\texttt{PEAT} las etapas de validación son las siguientes (Ver Figura
\ref{fig:pipeline}):
\begin{itemize}
\item Control de versiones: El equipo de desarrollo ingresa los cambios
  realizados al sistema por medio del control de versiones Git, esto inicia
  el proceso de despliegue.
\item Pruebas de unidad: Al detectarse un cambio en el repositorio se corren
  pruebas las pruebas de unidad del sistema. Se usa la biblioteca \texttt{RSpec}
  para implementar las pruebas de unidad para el código en Ruby, mientras que para
  el código en Javascript se hace uso de la biblioteca \texttt{Jasmine} para las
  pruebas de unidad. El equipo de desarrollo recibe retroalimentación del resultado
  de las pruebas, si el resultado es positivo se pasa a la siguiente etapa.
  En la primera secuencia en la Figura \ref{fig:pipeline} se tiene el caso
  cuando las pruebas de unidad son negativas y se detiene el proceso de despliegue.
\item Pruebas de aceptación: Se hace uso de la biblioteca \texttt{Cucumber}
  para implementar las pruebas de aceptación, de la misma forma que la etapa de
  pruebas de unidad si se obtiene un resultado positivo se continua a la siguiente
  etapa en caso contrario se detiene el proceso de despliegue.
\item Ambientes de prueba: Se hace el despliegue del sistema en los ambientes de
  prueba, es decir, a los ambientes \textit{peatstage}, \textit{peattest} y
  \textit{peatqa}. En esta etapa se realizan pruebas de rendimiento y de calidad
  de forma manual y automatizada.
\item Producción: se hace un despliegue a producción cuando la versión en los
  sistemas de prueba han sido revisado de forma satisfactoria.
\end{itemize}

\rjcimage{1.0}{imagenes/Deployment-Pipeline.png}{Proceso de despliegue para
  \texttt{PEAT}.}{pipeline}

Las primeras etapas del proceso se desarrollan en forma completamente automatizada
hasta llegar a la etapa de despliegue a los ambientes de pruebas, en esta etapa
al principio se realizaban pruebas de calidad y rendimiento de forma manual, estas
actividades se fueron automatizando conforme fue pasando el tiempo haciendo uso de
herramientas como \texttt{SauceLabs} y \texttt{CloudTest}. La ejecución para
el despliegue al ambiente de producción se realiza de forma manual.

\subsubsection{Herramientas}

El proceso de despliegue se hace uso de un gran numero de herramientas, las más
importantes son:

\begin{itemize}
\item \texttt{AWS}: \textit{Amazon Web Services} (AWS), es un conjunto de servicios
  de computo en la nube que permite la implementación de sistemas escalables.
\item \texttt{Jenkins}: es un servidor de despliegue continuo, que permite
  definir las etapas de un proceso de despliegue y las acciones que se realizan
  según el resultado de la etapa.
\item \texttt{Capistrano}: es una herramienta que facilita la creación de tareas
  para el despliegue de sistemas en servidores remotos.
\item \texttt{CloudTest}: es una herramienta para la ejecución de pruebas de
  carga y rendimiento para aplicaciones móviles y web.
\item \texttt{SauceLabs}: es una herramienta que permite ejecutar las pruebas de un
  sistema en mas de 500 combinaciones de navegadores, sistema operativos
  y dispositivos.
\end{itemize}

\subsection{Configuración y despliegue automatizado de ambientes}

Para el despliegue de los ambientes requeridos para \texttt{PEAT} se hizo uso de
\textit{Amazon Web Services} (AWS) en particular del servicio
\textit{Amazon Elastic Compute Cloud} (EC2) que permite la renta de servidores
para correr aplicaciones.

El uso de \texttt{EC2} presentaba las siguientes ventajas:
\begin{itemize}
\item Una comunicación mas rápida y segura con el \texttt{backend} dado que el
  servidor C3 corre bajo el servicio \texttt{EC2}.
\item Permite un gran margen de maniobra en la configuración de los servidores
  puesto que permite elegir entre una gran variedad de sistema operativos,
  capacidad de computo, etcétera.
\item Permite la creación y configuración automatizada de los servidores
  permitiendo que el sistema pueda escalar rápidamente según las necesidades
  de computo.
\end{itemize}

\subsubsection{Capistrano}

Para configurar los servidores del servicio \texttt{EC2} para \texttt{PEAT} se usa
\textit{Capistrano} que es una herramienta para definir y ejecutar tareas en
múltiples servidores remotos por medio de SSH\footnote{Es un protocolo que permite
  acceder a servidores remotos de forma segura a través de una red
  \cite{29_ssh_protocol}.}. Esta herramienta define un DSL basado en Ruby para la
definición de tareas de despliegue y mantenimiento.

\textit{Capistrano} contiene tareas predefinidas para el despliegue de sistemas
basados en el marco de trabajo Rails, sin embargo para el sistema \texttt{PEAT} se
implementaron tareas adicionales para realizar un despliegue exitoso.

\subsubsection{Configuración de ambientes}

\lstinputlisting[language=Ruby]{code/deploy-vars.rb}

El código anterior muestra la configuración base de variables para el
despliegue del sistema \texttt{PEAT} usando el DSL definido por \texttt{Capistrano}.
En las líneas 1-9 se definen las variables de configuración para el sistema
\texttt{PEAT} y el servidor Nginx, los valores por defecto están definidos
para un ambiente en producción, esto posteriormente facilita saber las diferencias
entre el ambiente de producción y los ambientes de pruebas.

En la linea 11 se definen los ambientes soportados, teniendo los cuatro
ambientes descritos anteriormente, cabe señalar que cada ambiente tiene
su propio archivo de configuración en donde se indican los cambios en variables
y/o tareas con respecto a la configuración base.

En las lineas 14-16 se indica el sistema de versiones, la dirección del repositorio
y la rama a usar para obtener el código fuente del sistema.
En \texttt{PEAT} el sistema de versiones es Git, donde la rama por defecto
es \textquote{release/v1.0} que es la rama estable del sistema que
se usa para producción, por medio de la variable de ambiente \texttt{BRANCH} es
posible hacer el despliegue de cualquier versión del sistema.

En las lineas 18-24 se tiene el uso de las declaraciones \texttt{after}
y \texttt{before} que permiten el establecer que una tarea sea realizada
antes o después de una segunda tarea. Cabe señalar que las tareas
\texttt{deploy:setup} y \texttt{deploy:restart} son tareas que son definidas
por \texttt{Capistrano}, la primera es una tarea para la configuración inicial
de un ambiente\footnote{Esta tarea es solo ejecutada una única vez para preparar
  un nuevo ambiente.} y la segunda tarea es realizada al reiniciar el sistema.

\lstinputlisting[language=Ruby]{code/deploy-tasks.rb}

En el código anterior se tiene las tareas mas importantes para el
despliegue del sistema. En las lineas 3-5 se define la tarea \texttt{upstart}
la cual por medio del comando \texttt{foreman} genera la configuración para agregar
al sistema \texttt{PEAT} como un servicio al sistema Upstart\footnote{Es un demonio
  que maneja el inicio de tareas y servicios durante el arranque del servidor y la
  supervisión de éstos mientras el servidor esta funcionando.} usado en el sistema
operativo Ubuntu 12.04 LTS que es el sistema operativo seleccionado para los
servidores EC2.

En las líneas 6-13 se definen las tareas para iniciar y parar el sistema
\texttt{PEAT}, se hace uso de los comandos \texttt{start} y \texttt{stop} y
de la configuración generada para el sistema Upstart en la tarea anterior para
iniciar o parar fácilmente el sistema.

En las lineas 15-19 se define la tarea \texttt{peat\_setup} la cual genera
los archivos de configuración para \texttt{PEAT} (\texttt{peat.yml}) y
Nginx (\texttt{nginx.conf}) y posteriormente los transfiere a los servidores
del ambiente, esta tarea se ejecuta solamente cuando se inicializa un nuevo
ambiente.

En las lineas 21-27 se define la tarea \texttt{config\_sync} la cual
hace lo mismo que la tarea anterior pero en el contexto de que el ambiente
ya esta en linea por lo que al finalizar la tarea se reinicia el sistema.

En las lineas 30-35 se define la tarea \texttt{config} la cual genera
los archivos de configuración para \texttt{PEAT} (\texttt{peat.yml}) y
Nginx (\texttt{nginx.conf}) por medio de la clase \texttt{ConfigCreator}.

\lstinputlisting[language=Ruby]{code/deploy-peatstage.rb}

Como se menciono antes cada ambiente tiene su propio archivo de configuración,
el código anterior es la configuración para el ambiente \texttt{peatstage}.

En la linea 1-2 se define el servidor asociado al ambiente. En las lineas
3-10 se redefinen varias variables de configuración para el ambiente siendo uno
de los principales cambios que la rama por defecto es \textquote{master} la
cual es la rama principal de desarrollo en el sistema \texttt{PEAT}.
En las líneas 29-46 se redefinen las tareas \texttt{peat\_setup},
\texttt{config\_sync} y \texttt{config} para que tomen en cuenta la configuración
actualizada por medio del método \texttt{override\_defaults}.

\subsubsection{Despliegue automatizado de ambientes}

La interacción con \texttt{Capistrano} es por medio del comando \texttt{cap}
en la linea de comandos, así para hacer un despliegue al ambiente \texttt{peatprod}
se ejecutaría el siguiente comando.

\begin{verbatim}
cap peatprod deploy
\end{verbatim}

El comando \texttt{cap} toma dos argumentos el primero es algunos de los
ambientes definidos en la variable \texttt{stages} y el segundo es el nombre
de la tarea a realizar.

Como se puede ver por medio de \texttt{Capistrano} se puede realizar tanto
la configuración inicial de los ambientes y el despliegue del sistema \texttt{PEAT}.

El uso de \texttt{Capistrano} para el despliegue tiene las siguientes ventajas:
\begin{itemize}
\item Rápidamente se puede agregar un nuevo ambiente agregando su nombre a la
  variable \texttt{stages} y agregando su archivo de configuración con los
  cambios deseados para este nuevo ambiente.
\item La configuración definida con \texttt{Capistrano} es parte del código fuente
  del sistema y se encuentra en el sistema de versiones por lo que se tiene historia
  de los cambios realizados en la configuración de los ambientes.
\item El sistema es auto contenido, es decir, el código para realizar el despliegue
  del sistema es parte del código fuente del sistema.
\end{itemize}

En el servidor Jenkins se implemento una tarea que al tenerse un resultado
positivos de las pruebas del sistema se hace uso del comando \texttt{cap}
para efectuar el despliegue del sistema en los ambientes de prueba.

\subsection{Pruebas de unidad y aceptación}

En el servidor Jenkins se definen las etapas del proceso de despliegue, siendo
el inicio del proceso de despliegue cuando se detecta un cambio en el repositorio
del sistema. Al detectarse este cambio se ejecuta la primera etapa que implica
correr las pruebas de unidad.

\subsubsection{Pruebas de unidad}

En la sección 2.3.2 se hablo sobre la practica del desarrollo guiado por
comportamiento (\textit{Behavior Driven Development}, BDD) la cual involucra
escribir las pruebas antes de escribir el código fuente y la refactorización
continua del código fuente.

En BDD las pruebas se enfocan en describir el comportamiento y la interacción
de los módulos del sistema. Para el sistema \texttt{PEAT} se hace uso del marco
de trabajo \textit{RSpec} la cual define un lenguaje de dominio específico (DSL)
para implementar las pruebas unitarias.

\texttt{RSpec} da acceso al comando \texttt{rspec} que permite correr y verificar
que el sistema pasa todas las pruebas del sistema. Por medio del comando
\texttt{rspec} el servidor Jenkins puede automáticamente verificar que el
sistema sigue pasando todas la pruebas unitarias.


Así en la primera etapa el servidor Jenkins obtiene el código fuente del sistema
y ejecuta el comando \texttt{rspec} el cual ejecuta todas las pruebas de unidad
dentro del sistema.

\lstinputlisting[language=Ruby]{code/rspec-questions-controller.rb}

